// tslint:disable
/**
 * Mediashare
 * Media Share API
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { HttpMethods, QueryConfig, ResponseBody, ResponseText } from 'redux-query';
import * as runtime from '../runtime';
import {
  PlaylistResponseDto,
  PlaylistResponseDtoFromJSON,
  PlaylistResponseDtoToJSON,
  UpdateUserDto,
  UpdateUserDtoFromJSON,
  UpdateUserDtoToJSON,
  UserDto,
  UserDtoFromJSON,
  UserDtoToJSON,
} from '../models';

export interface UsersControllerFindOneRequest {
  userId: string;
}

export interface UsersControllerGetPlaylistsRequest {
  userId: string;
}

export interface UsersControllerReadSharedItemRequest {
  shareId: string;
}

export interface UsersControllerRemoveRequest {
  userId: string;
}

export interface UsersControllerSetRolesRequest {
  userId: string;
  requestBody: Array<string>;
}

export interface UsersControllerUpdateRequest {
  userId: string;
  updateUserDto: UpdateUserDto;
}

/**
 */
function usersControllerCreateRaw<T>(requestConfig: runtime.TypedQueryConfig<T, UserDto> = {}): QueryConfig<T> {
  let queryParameters = null;

  const headerParameters: runtime.HttpHeaders = {};

  const { meta = {} } = requestConfig;

  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/api/users`,
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: 'POST',
      headers: headerParameters,
    },
    body: queryParameters,
  };

  const { transform: requestTransform } = requestConfig;
  if (requestTransform) {
    config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(UserDtoFromJSON(body), text);
  }

  return config;
}

/**
 */
export function usersControllerCreate<T>(requestConfig?: runtime.TypedQueryConfig<T, UserDto>): QueryConfig<T> {
  return usersControllerCreateRaw(requestConfig);
}

/**
 */
function usersControllerFindAllRaw<T>(requestConfig: runtime.TypedQueryConfig<T, Array<UserDto>> = {}): QueryConfig<T> {
  let queryParameters = null;

  const headerParameters: runtime.HttpHeaders = {};

  const { meta = {} } = requestConfig;

  meta.authType = ['bearer'];
  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/api/users`,
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: 'GET',
      headers: headerParameters,
    },
    body: queryParameters,
  };

  const { transform: requestTransform } = requestConfig;
  if (requestTransform) {
    config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(body.map(UserDtoFromJSON), text);
  }

  return config;
}

/**
 */
export function usersControllerFindAll<T>(requestConfig?: runtime.TypedQueryConfig<T, Array<UserDto>>): QueryConfig<T> {
  return usersControllerFindAllRaw(requestConfig);
}

/**
 */
function usersControllerFindOneRaw<T>(
  requestParameters: UsersControllerFindOneRequest,
  requestConfig: runtime.TypedQueryConfig<T, UserDto> = {}
): QueryConfig<T> {
  if (requestParameters.userId === null || requestParameters.userId === undefined) {
    throw new runtime.RequiredError('userId', 'Required parameter requestParameters.userId was null or undefined when calling usersControllerFindOne.');
  }

  let queryParameters = null;

  const headerParameters: runtime.HttpHeaders = {};

  const { meta = {} } = requestConfig;

  meta.authType = ['bearer'];
  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/api/users/{userId}`.replace(`{${'userId'}}`, encodeURIComponent(String(requestParameters.userId))),
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: 'GET',
      headers: headerParameters,
    },
    body: queryParameters,
  };

  const { transform: requestTransform } = requestConfig;
  if (requestTransform) {
    config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(UserDtoFromJSON(body), text);
  }

  return config;
}

/**
 */
export function usersControllerFindOne<T>(
  requestParameters: UsersControllerFindOneRequest,
  requestConfig?: runtime.TypedQueryConfig<T, UserDto>
): QueryConfig<T> {
  return usersControllerFindOneRaw(requestParameters, requestConfig);
}

/**
 */
function usersControllerGetPlaylistsRaw<T>(
  requestParameters: UsersControllerGetPlaylistsRequest,
  requestConfig: runtime.TypedQueryConfig<T, Array<PlaylistResponseDto>> = {}
): QueryConfig<T> {
  if (requestParameters.userId === null || requestParameters.userId === undefined) {
    throw new runtime.RequiredError('userId', 'Required parameter requestParameters.userId was null or undefined when calling usersControllerGetPlaylists.');
  }

  let queryParameters = null;

  const headerParameters: runtime.HttpHeaders = {};

  const { meta = {} } = requestConfig;

  meta.authType = ['bearer'];
  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/api/users/{userId}/playlists`.replace(`{${'userId'}}`, encodeURIComponent(String(requestParameters.userId))),
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: 'GET',
      headers: headerParameters,
    },
    body: queryParameters,
  };

  const { transform: requestTransform } = requestConfig;
  if (requestTransform) {
    config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(body.map(PlaylistResponseDtoFromJSON), text);
  }

  return config;
}

/**
 */
export function usersControllerGetPlaylists<T>(
  requestParameters: UsersControllerGetPlaylistsRequest,
  requestConfig?: runtime.TypedQueryConfig<T, Array<PlaylistResponseDto>>
): QueryConfig<T> {
  return usersControllerGetPlaylistsRaw(requestParameters, requestConfig);
}

/**
 */
function usersControllerReadSharedItemRaw<T>(
  requestParameters: UsersControllerReadSharedItemRequest,
  requestConfig: runtime.TypedQueryConfig<T, UserDto> = {}
): QueryConfig<T> {
  if (requestParameters.shareId === null || requestParameters.shareId === undefined) {
    throw new runtime.RequiredError(
      'shareId',
      'Required parameter requestParameters.shareId was null or undefined when calling usersControllerReadSharedItem.'
    );
  }

  let queryParameters = null;

  const headerParameters: runtime.HttpHeaders = {};

  const { meta = {} } = requestConfig;

  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/api/users/shared-items/{shareId}`.replace(`{${'shareId'}}`, encodeURIComponent(String(requestParameters.shareId))),
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: 'POST',
      headers: headerParameters,
    },
    body: queryParameters,
  };

  const { transform: requestTransform } = requestConfig;
  if (requestTransform) {
    config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(UserDtoFromJSON(body), text);
  }

  return config;
}

/**
 */
export function usersControllerReadSharedItem<T>(
  requestParameters: UsersControllerReadSharedItemRequest,
  requestConfig?: runtime.TypedQueryConfig<T, UserDto>
): QueryConfig<T> {
  return usersControllerReadSharedItemRaw(requestParameters, requestConfig);
}

/**
 */
function usersControllerRemoveRaw<T>(requestParameters: UsersControllerRemoveRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
  if (requestParameters.userId === null || requestParameters.userId === undefined) {
    throw new runtime.RequiredError('userId', 'Required parameter requestParameters.userId was null or undefined when calling usersControllerRemove.');
  }

  let queryParameters = null;

  const headerParameters: runtime.HttpHeaders = {};

  const { meta = {} } = requestConfig;

  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/api/users/{userId}`.replace(`{${'userId'}}`, encodeURIComponent(String(requestParameters.userId))),
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: 'DELETE',
      headers: headerParameters,
    },
    body: queryParameters,
  };

  const { transform: requestTransform } = requestConfig;
  if (requestTransform) {
  }

  return config;
}

/**
 */
export function usersControllerRemove<T>(requestParameters: UsersControllerRemoveRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
  return usersControllerRemoveRaw(requestParameters, requestConfig);
}

/**
 */
function usersControllerSetRolesRaw<T>(
  requestParameters: UsersControllerSetRolesRequest,
  requestConfig: runtime.TypedQueryConfig<T, UserDto> = {}
): QueryConfig<T> {
  if (requestParameters.userId === null || requestParameters.userId === undefined) {
    throw new runtime.RequiredError('userId', 'Required parameter requestParameters.userId was null or undefined when calling usersControllerSetRoles.');
  }

  if (requestParameters.requestBody === null || requestParameters.requestBody === undefined) {
    throw new runtime.RequiredError(
      'requestBody',
      'Required parameter requestParameters.requestBody was null or undefined when calling usersControllerSetRoles.'
    );
  }

  let queryParameters = null;

  const headerParameters: runtime.HttpHeaders = {};

  headerParameters['Content-Type'] = 'application/json';

  const { meta = {} } = requestConfig;

  meta.authType = ['bearer'];
  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/api/users/{userId}/roles`.replace(`{${'userId'}}`, encodeURIComponent(String(requestParameters.userId))),
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: 'PUT',
      headers: headerParameters,
    },
    body: queryParameters || requestParameters.requestBody,
  };

  const { transform: requestTransform } = requestConfig;
  if (requestTransform) {
    config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(UserDtoFromJSON(body), text);
  }

  return config;
}

/**
 */
export function usersControllerSetRoles<T>(
  requestParameters: UsersControllerSetRolesRequest,
  requestConfig?: runtime.TypedQueryConfig<T, UserDto>
): QueryConfig<T> {
  return usersControllerSetRolesRaw(requestParameters, requestConfig);
}

/**
 */
function usersControllerUpdateRaw<T>(
  requestParameters: UsersControllerUpdateRequest,
  requestConfig: runtime.TypedQueryConfig<T, UserDto> = {}
): QueryConfig<T> {
  if (requestParameters.userId === null || requestParameters.userId === undefined) {
    throw new runtime.RequiredError('userId', 'Required parameter requestParameters.userId was null or undefined when calling usersControllerUpdate.');
  }

  if (requestParameters.updateUserDto === null || requestParameters.updateUserDto === undefined) {
    throw new runtime.RequiredError(
      'updateUserDto',
      'Required parameter requestParameters.updateUserDto was null or undefined when calling usersControllerUpdate.'
    );
  }

  let queryParameters = null;

  const headerParameters: runtime.HttpHeaders = {};

  headerParameters['Content-Type'] = 'application/json';

  const { meta = {} } = requestConfig;

  meta.authType = ['bearer'];
  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/api/users/{userId}`.replace(`{${'userId'}}`, encodeURIComponent(String(requestParameters.userId))),
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: 'PUT',
      headers: headerParameters,
    },
    body: queryParameters || UpdateUserDtoToJSON(requestParameters.updateUserDto),
  };

  const { transform: requestTransform } = requestConfig;
  if (requestTransform) {
    config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(UserDtoFromJSON(body), text);
  }

  return config;
}

/**
 */
export function usersControllerUpdate<T>(
  requestParameters: UsersControllerUpdateRequest,
  requestConfig?: runtime.TypedQueryConfig<T, UserDto>
): QueryConfig<T> {
  return usersControllerUpdateRaw(requestParameters, requestConfig);
}
