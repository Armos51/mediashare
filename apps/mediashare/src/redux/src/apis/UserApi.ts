// tslint:disable
/**
 * Mediashare
 * Media Share API
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { HttpMethods, QueryConfig, ResponseBody, ResponseText } from 'redux-query';
import * as runtime from '../runtime';
import {
  LoginDto,
  LoginDtoFromJSON,
  LoginDtoToJSON,
  LoginResponseDto,
  LoginResponseDtoFromJSON,
  LoginResponseDtoToJSON,
  MediaItemDto,
  MediaItemDtoFromJSON,
  MediaItemDtoToJSON,
  Playlist,
  PlaylistFromJSON,
  PlaylistToJSON,
  ShareItem,
  ShareItemFromJSON,
  ShareItemToJSON,
  TokenDto,
  TokenDtoFromJSON,
  TokenDtoToJSON,
  UserDto,
  UserDtoFromJSON,
  UserDtoToJSON,
} from '../models';

export interface UserControllerAuthorizeRequest {
  id: string;
  tokenDto: TokenDto;
}

export interface UserControllerLoginRequest {
  loginDto: LoginDto;
}

/**
 */
function userControllerAuthorizeRaw<T>(
  requestParameters: UserControllerAuthorizeRequest,
  requestConfig: runtime.TypedQueryConfig<T, void> = {}
): QueryConfig<T> {
  if (requestParameters.id === null || requestParameters.id === undefined) {
    throw new runtime.RequiredError(
      'id',
      'Required parameter requestParameters.id was null or undefined when calling userControllerAuthorize.'
    );
  }

  if (requestParameters.tokenDto === null || requestParameters.tokenDto === undefined) {
    throw new runtime.RequiredError(
      'tokenDto',
      'Required parameter requestParameters.tokenDto was null or undefined when calling userControllerAuthorize.'
    );
  }

  let queryParameters = null;

  const headerParameters: runtime.HttpHeaders = {};

  headerParameters['Content-Type'] = 'application/json';

  const { meta = {} } = requestConfig;

  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/api/user/authorize`.replace(
      `{${':id'}}`,
      encodeURIComponent(String(requestParameters.id))
    ),
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: 'POST',
      headers: headerParameters,
    },
    body: queryParameters || TokenDtoToJSON(requestParameters.tokenDto),
  };

  const { transform: requestTransform } = requestConfig;
  if (requestTransform) {
  }

  return config;
}

/**
 */
export function userControllerAuthorize<T>(
  requestParameters: UserControllerAuthorizeRequest,
  requestConfig?: runtime.TypedQueryConfig<T, void>
): QueryConfig<T> {
  return userControllerAuthorizeRaw(requestParameters, requestConfig);
}

/**
 */
function userControllerGetMediaItemsRaw<T>(requestConfig: runtime.TypedQueryConfig<T, UserDto> = {}): QueryConfig<T> {
  let queryParameters = null;

  const headerParameters: runtime.HttpHeaders = {};

  const { meta = {} } = requestConfig;

  meta.authType = ['bearer'];
  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/api/user/media-items`,
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: 'GET',
      headers: headerParameters,
    },
    body: queryParameters,
  };

  const { transform: requestTransform } = requestConfig;
  if (requestTransform) {
    config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(UserDtoFromJSON(body), text);
  }

  return config;
}

/**
 */
export function userControllerGetMediaItems<T>(requestConfig?: runtime.TypedQueryConfig<T, UserDto>): QueryConfig<T> {
  return userControllerGetMediaItemsRaw(requestConfig);
}

/**
 */
function userControllerGetMyShareItemsRaw<T>(
  requestConfig: runtime.TypedQueryConfig<T, Array<ShareItem>> = {}
): QueryConfig<T> {
  let queryParameters = null;

  const headerParameters: runtime.HttpHeaders = {};

  const { meta = {} } = requestConfig;

  meta.authType = ['bearer'];
  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/api/user/playlists/shared`,
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: 'GET',
      headers: headerParameters,
    },
    body: queryParameters,
  };

  const { transform: requestTransform } = requestConfig;
  if (requestTransform) {
    config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(body.map(ShareItemFromJSON), text);
  }

  return config;
}

/**
 */
export function userControllerGetMyShareItems<T>(
  requestConfig?: runtime.TypedQueryConfig<T, Array<ShareItem>>
): QueryConfig<T> {
  return userControllerGetMyShareItemsRaw(requestConfig);
}

/**
 */
function userControllerGetPlaylistsRaw<T>(requestConfig: runtime.TypedQueryConfig<T, Playlist> = {}): QueryConfig<T> {
  let queryParameters = null;

  const headerParameters: runtime.HttpHeaders = {};

  const { meta = {} } = requestConfig;

  meta.authType = ['bearer'];
  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/api/user/playlists`,
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: 'GET',
      headers: headerParameters,
    },
    body: queryParameters,
  };

  const { transform: requestTransform } = requestConfig;
  if (requestTransform) {
    config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(PlaylistFromJSON(body), text);
  }

  return config;
}

/**
 */
export function userControllerGetPlaylists<T>(requestConfig?: runtime.TypedQueryConfig<T, Playlist>): QueryConfig<T> {
  return userControllerGetPlaylistsRaw(requestConfig);
}

/**
 */
function userControllerGetSharedMediaItemsRaw<T>(
  requestConfig: runtime.TypedQueryConfig<T, Array<MediaItemDto>> = {}
): QueryConfig<T> {
  let queryParameters = null;

  const headerParameters: runtime.HttpHeaders = {};

  const { meta = {} } = requestConfig;

  meta.authType = ['bearer'];
  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/api/user/media-items/shared`,
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: 'GET',
      headers: headerParameters,
    },
    body: queryParameters,
  };

  const { transform: requestTransform } = requestConfig;
  if (requestTransform) {
    config.transform = (body: ResponseBody, text: ResponseBody) =>
      requestTransform(body.map(MediaItemDtoFromJSON), text);
  }

  return config;
}

/**
 */
export function userControllerGetSharedMediaItems<T>(
  requestConfig?: runtime.TypedQueryConfig<T, Array<MediaItemDto>>
): QueryConfig<T> {
  return userControllerGetSharedMediaItemsRaw(requestConfig);
}

/**
 */
function userControllerGetUserRaw<T>(requestConfig: runtime.TypedQueryConfig<T, UserDto> = {}): QueryConfig<T> {
  let queryParameters = null;

  const headerParameters: runtime.HttpHeaders = {};

  const { meta = {} } = requestConfig;

  meta.authType = ['bearer'];
  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/api/user`,
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: 'GET',
      headers: headerParameters,
    },
    body: queryParameters,
  };

  const { transform: requestTransform } = requestConfig;
  if (requestTransform) {
    config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(UserDtoFromJSON(body), text);
  }

  return config;
}

/**
 */
export function userControllerGetUser<T>(requestConfig?: runtime.TypedQueryConfig<T, UserDto>): QueryConfig<T> {
  return userControllerGetUserRaw(requestConfig);
}

/**
 */
function userControllerLoginRaw<T>(
  requestParameters: UserControllerLoginRequest,
  requestConfig: runtime.TypedQueryConfig<T, LoginResponseDto> = {}
): QueryConfig<T> {
  if (requestParameters.loginDto === null || requestParameters.loginDto === undefined) {
    throw new runtime.RequiredError(
      'loginDto',
      'Required parameter requestParameters.loginDto was null or undefined when calling userControllerLogin.'
    );
  }

  let queryParameters = null;

  const headerParameters: runtime.HttpHeaders = {};

  headerParameters['Content-Type'] = 'application/json';

  const { meta = {} } = requestConfig;

  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/api/user/login`,
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: 'POST',
      headers: headerParameters,
    },
    body: queryParameters || LoginDtoToJSON(requestParameters.loginDto),
  };

  const { transform: requestTransform } = requestConfig;
  if (requestTransform) {
    config.transform = (body: ResponseBody, text: ResponseBody) =>
      requestTransform(LoginResponseDtoFromJSON(body), text);
  }

  return config;
}

/**
 */
export function userControllerLogin<T>(
  requestParameters: UserControllerLoginRequest,
  requestConfig?: runtime.TypedQueryConfig<T, LoginResponseDto>
): QueryConfig<T> {
  return userControllerLoginRaw(requestParameters, requestConfig);
}

/**
 */
function userControllerLogoutRaw<T>(requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
  let queryParameters = null;

  const headerParameters: runtime.HttpHeaders = {};

  const { meta = {} } = requestConfig;

  meta.authType = ['bearer'];
  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/api/user/logout`,
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: 'POST',
      headers: headerParameters,
    },
    body: queryParameters,
  };

  const { transform: requestTransform } = requestConfig;
  if (requestTransform) {
  }

  return config;
}

/**
 */
export function userControllerLogout<T>(requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
  return userControllerLogoutRaw(requestConfig);
}
